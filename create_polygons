
create or replace table test1.polygons as
with  
f as (
    select t as ft, machineId from test1.fendt order by machineId, ft
),
w as (
  select date_diff(datetime, timestamp('1970-01-01 00:00:00'), second) as dt, unit_id from `test1.wialon` order by unit_id, dt
),
mjoined as (
    select f.machineid, f.ft, w.dt, w.unit_id
    from f
    inner join test1.fendtWialon as fw on fw.machineId = f.machineId
    inner join w on w.unit_id = fw.unit_id and round(w.dt / 10) = round(f.ft / 10)
),
fwjoin as 
    (select mjoined.machineId, mjoined.unit_id, mjoined.dt, max(mjoined.ft) as ft
    from mjoined 
    group by mjoined.machineId, mjoined.unit_id, mjoined.dt
    order by mjoined.machineId, mjoined.unit_id, mjoined.dt
),
joined as
    (select w.unit_id, w.dateTime, w.gpsLatitude, w.gpsLongitude, f.machineId
    from test1.fendt as f, test1.wialon as w, fwjoin
    where f.machineId = fwjoin.machineID and f.t = fwjoin.ft 
    and w.unit_id = fwjoin.unit_id and w.datetime = cast( PARSE_DATETIME('%s', CAST(TRUNC(fwjoin.dt) AS STRING)) as timestamp)
    and  w.gpsLatitude is not null and w.gpsLongitude is not null
),
prevnext as (
  select unit_id, machineId, datetime, gpsLongitude, gpsLatitude,
  LEAD(gpsLongitude) OVER (PARTITION BY unit_id ORDER BY datetime) AS nextGpsLongitude,
  LAG(gpsLongitude) OVER (PARTITION BY unit_id ORDER BY datetime) AS prevGpsLongitude,
  LEAD(gpsLatitude) OVER (PARTITION BY unit_id ORDER BY datetime) AS nextGpsLatitude,
  LAG(gpsLatitude) OVER (PARTITION BY unit_id ORDER BY datetime) AS prevGpsLatitude,
  from joined
  order by unit_id, datetime
),
addStartStop as (
  select unit_id, machineId, datetime, gpsLongitude, gpsLatitude,
  case 
      when (abs(gpsLongitude * 1000 - prevGpsLongitude * 1000) >1) then 'start'
      when (abs(gpsLatitude * 1000 - prevGpsLatitude * 1000)>1) then 'start'
      when (abs(gpsLongitude * 1000 - nextGpsLongitude * 1000)>1) then 'stop'
      when (abs(gpsLatitude * 1000 - nextGpsLatitude * 1000)>1) then 'stop'
      else ''
  end as running
  from prevnext
  order by unit_id, datetime
),
startStop as (
  select * from addStartStop
  where running = 'start' or running = 'stop'
),
intervals as (
  select unit_id, datetime as startDateTime, running as startState, gpsLongitude as startLongitude, gpsLatitude as startLatitude,
        Lead(datetime) over (PARTITION BY unit_id ORDER BY datetime) AS stopDateTime,
        Lead(running) over (PARTITION BY unit_id ORDER BY datetime) AS stopState,
        Lead(gpsLongitude) over (PARTITION BY unit_id ORDER BY datetime) AS stopLongitude,
        Lead(gpsLatitude) over (PARTITION BY unit_id ORDER BY datetime) AS stopLatitude
  from startstop
),
fixedIntervals as (
  select * from intervals where startState = 'start' and stopState = 'stop'
),
IntervalsWithGps as (
  select i.unit_id, i.startDateTime, i.StopDateTime, i.startLongitude, i.startLatitude, j.datetime, j.gpsLongitude, j.gpsLatitude
  from fixedIntervals as i, joined as j
  where i.unit_id = j.unit_id and j.datetime >=i.startDateTime and j.datetime <= i.stopDateTime
  order by unit_id, i.startDateTime, j.datetime 
), 
joinedStrings as (
  select unit_id, startDateTime, stopDateTime, startLongitude, startLatitude, count(*) cnt,
    concat('POLYGON((',string_agg(concat(gpsLongitude, ' ', gpsLatitude), ',' order by datetime), ',', startLongitude, ' ', startLatitude, '))') as poly,
    concat('LINESTRING(',string_agg(concat(gpsLongitude, ' ', gpsLatitude), ',' order by datetime), ')') as multiline
  from intervalsWithGps
  group by unit_id, startDateTime, stopDateTime, startLongitude, startLatitude
)
select unit_id, startDateTime, stopDateTime, startLongitude, startLatitude, cnt,
    st_geogfromtext(poly, make_valid => TRUE) as poly,
    st_geogfromtext(multiline, make_valid => TRUE) as multiline,
    st_length(st_geogfromtext(multiline,make_valid => TRUE)) as len
from joinedStrings
where cnt>10

limit 1000
